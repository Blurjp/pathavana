#!/usr/bin/env python3
"""
Migration management utilities for Pathavana.
Simplifies common Alembic operations.
"""

import subprocess
import sys
import os
from pathlib import Path
from datetime import datetime
import re

# Add the backend directory to the path
sys.path.append(str(Path(__file__).parent.parent))


class MigrationManager:
    """Manage database migrations with Alembic."""
    
    def __init__(self):
        self.backend_dir = Path(__file__).parent.parent
        self.alembic_dir = self.backend_dir / "alembic"
        self.versions_dir = self.alembic_dir / "versions"
    
    def run_alembic_command(self, *args):
        """Run an alembic command and return the result."""
        cmd = ["alembic"] + list(args)
        
        try:
            result = subprocess.run(
                cmd,
                cwd=self.backend_dir,
                capture_output=True,
                text=True
            )
            
            if result.returncode != 0:
                print(f"Error: {result.stderr}")
                return False, result.stderr
            
            return True, result.stdout
            
        except Exception as e:
            print(f"Error running command: {e}")
            return False, str(e)
    
    def create_migration(self, message: str, autogenerate: bool = True):
        """Create a new migration."""
        print(f"Creating {'autogenerated' if autogenerate else 'empty'} migration: {message}")
        
        args = ["revision", "-m", message]
        if autogenerate:
            args.insert(1, "--autogenerate")
        
        success, output = self.run_alembic_command(*args)
        
        if success:
            # Extract the generated file path
            match = re.search(r"Generating (.*\.py)", output)
            if match:
                migration_file = match.group(1)
                print(f"✅ Migration created: {migration_file}")
                
                # Offer to edit the migration
                response = input("\nEdit the migration file? (y/N): ")
                if response.lower() == 'y':
                    editor = os.environ.get('EDITOR', 'vim')
                    subprocess.run([editor, migration_file])
            else:
                print(f"✅ Migration created successfully")
                print(output)
        
        return success
    
    def list_migrations(self):
        """List all migrations."""
        print("Current migrations:")
        print("-" * 60)
        
        # Get current revision
        success, output = self.run_alembic_command("current")
        if success:
            print(f"Current revision: {output.strip()}")
        
        print("\nMigration history:")
        success, output = self.run_alembic_command("history", "--verbose")
        
        if success:
            print(output)
        
        return success
    
    def upgrade(self, revision: str = "head"):
        """Upgrade to a specific revision."""
        print(f"Upgrading database to: {revision}")
        
        success, output = self.run_alembic_command("upgrade", revision)
        
        if success:
            print(f"✅ Successfully upgraded to {revision}")
            print(output)
        
        return success
    
    def downgrade(self, revision: str):
        """Downgrade to a specific revision."""
        print(f"Downgrading database to: {revision}")
        
        response = input("\n⚠️  This will downgrade your database. Continue? (y/N): ")
        if response.lower() != 'y':
            print("Downgrade cancelled.")
            return False
        
        success, output = self.run_alembic_command("downgrade", revision)
        
        if success:
            print(f"✅ Successfully downgraded to {revision}")
            print(output)
        
        return success
    
    def show_sql(self, start_revision: str = None, end_revision: str = "head"):
        """Show SQL that would be executed for an upgrade."""
        print(f"Showing SQL for upgrade {'from ' + start_revision if start_revision else ''} to {end_revision}")
        
        args = ["upgrade", end_revision, "--sql"]
        if start_revision:
            args = ["upgrade", f"{start_revision}:{end_revision}", "--sql"]
        
        success, output = self.run_alembic_command(*args)
        
        if success:
            print("\nGenerated SQL:")
            print("-" * 60)
            print(output)
        
        return success
    
    def check_pending(self):
        """Check for pending migrations."""
        success, current = self.run_alembic_command("current")
        if not success:
            return False
        
        success, heads = self.run_alembic_command("heads")
        if not success:
            return False
        
        current_rev = current.strip().split(' ')[0] if current.strip() else None
        head_rev = heads.strip().split(' ')[0] if heads.strip() else None
        
        if current_rev == head_rev:
            print("✅ Database is up to date!")
            return True
        else:
            print(f"⚠️  Database is not up to date!")
            print(f"Current: {current_rev or 'None'}")
            print(f"Latest: {head_rev}")
            
            # Show pending migrations
            print("\nPending migrations:")
            self.run_alembic_command("history", f"{current_rev or 'base'}:head")
            
            return False
    
    def stamp(self, revision: str):
        """Stamp the database with a specific revision without running migrations."""
        print(f"Stamping database with revision: {revision}")
        
        response = input("\n⚠️  This will mark migrations as applied without running them. Continue? (y/N): ")
        if response.lower() != 'y':
            print("Stamp cancelled.")
            return False
        
        success, output = self.run_alembic_command("stamp", revision)
        
        if success:
            print(f"✅ Successfully stamped database with {revision}")
            print(output)
        
        return success
    
    def validate(self):
        """Validate that migrations can be applied cleanly."""
        print("Validating migrations...")
        
        # Check if we can generate a migration without changes
        success, output = self.run_alembic_command("check")
        
        if success:
            print("✅ Migration validation passed!")
        else:
            if "Target database is not up to date" in output:
                print("⚠️  Database has pending migrations")
                self.check_pending()
            else:
                print("❌ Migration validation failed!")
        
        return success


def main():
    """Main migration management function."""
    manager = MigrationManager()
    
    if len(sys.argv) > 1:
        command = sys.argv[1].lower()
        
        if command == "create":
            if len(sys.argv) < 3:
                print("Usage: manage_migrations.py create <message> [--empty]")
                sys.exit(1)
            
            message = sys.argv[2]
            autogenerate = "--empty" not in sys.argv
            manager.create_migration(message, autogenerate)
        
        elif command == "list":
            manager.list_migrations()
        
        elif command == "upgrade":
            revision = sys.argv[2] if len(sys.argv) > 2 else "head"
            manager.upgrade(revision)
        
        elif command == "downgrade":
            if len(sys.argv) < 3:
                print("Usage: manage_migrations.py downgrade <revision>")
                sys.exit(1)
            
            manager.downgrade(sys.argv[2])
        
        elif command == "sql":
            start = sys.argv[2] if len(sys.argv) > 2 else None
            end = sys.argv[3] if len(sys.argv) > 3 else "head"
            manager.show_sql(start, end)
        
        elif command == "check":
            manager.check_pending()
        
        elif command == "stamp":
            if len(sys.argv) < 3:
                print("Usage: manage_migrations.py stamp <revision>")
                sys.exit(1)
            
            manager.stamp(sys.argv[2])
        
        elif command == "validate":
            manager.validate()
        
        else:
            print(f"Unknown command: {command}")
            print("\nAvailable commands:")
            print("  create <message> [--empty]  - Create a new migration")
            print("  list                       - List all migrations")
            print("  upgrade [revision]         - Upgrade database")
            print("  downgrade <revision>       - Downgrade database")
            print("  sql [start] [end]         - Show SQL for upgrade")
            print("  check                     - Check for pending migrations")
            print("  stamp <revision>          - Stamp database with revision")
            print("  validate                  - Validate migrations")
            sys.exit(1)
    
    else:
        # Interactive mode
        print("Pathavana Migration Manager")
        print("=" * 50)
        
        while True:
            print("\nOptions:")
            print("1. Create new migration")
            print("2. List migrations")
            print("3. Upgrade database")
            print("4. Downgrade database")
            print("5. Check pending migrations")
            print("6. Show upgrade SQL")
            print("7. Validate migrations")
            print("0. Exit")
            
            choice = input("\nSelect option: ")
            
            if choice == "1":
                message = input("Migration message: ")
                auto = input("Auto-generate from models? (Y/n): ")
                manager.create_migration(message, auto.lower() != 'n')
            
            elif choice == "2":
                manager.list_migrations()
            
            elif choice == "3":
                revision = input("Target revision (default: head): ") or "head"
                manager.upgrade(revision)
            
            elif choice == "4":
                revision = input("Target revision: ")
                if revision:
                    manager.downgrade(revision)
            
            elif choice == "5":
                manager.check_pending()
            
            elif choice == "6":
                start = input("Start revision (optional): ")
                end = input("End revision (default: head): ") or "head"
                manager.show_sql(start if start else None, end)
            
            elif choice == "7":
                manager.validate()
            
            elif choice == "0":
                print("Exiting.")
                break
            
            else:
                print("Invalid option.")


if __name__ == "__main__":
    main()